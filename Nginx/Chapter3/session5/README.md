# 信号编程进阶、sigprocmask范例
1. 在真实的项目中，后台服务程序不受终端控制，程序在内存中运行，没有交互的界面，程序在内存中周期性或通过事件唤醒的方式执行任务。
2. 信号是用来通知进程发生了什么事件，无法给进程传递任何数据，进程对信号的处理方法有三种：
* 忽略某个信号，进程对该信号不做任何处理，就像未发生过一样。
a) 
3. 信号处理函数被中断
* 当一个信号到达后，进程会调用信号处理函数，如果这个时候进程接收了其他的信号，那么进程会中断之前的信号处理函数，等新的信号处理函数执行完成后再继续执行之前的信号处理函数。
* 当一个信号到达后，进程会调用信号处理函数，如果这个时候进程接收了与之前相同的信号，那么进程会对信号处理函数中信号做排队阻塞处理。
<details><summary>展开/收起</summary>
<pre><code>

#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void exectask()
{
    printf("执行了一次任务！\n");
}

void func(int sig)
{
    for (int i = 0; i < 6; i++)
    {
        printf("收到了信号%d，第%d\n", sig, i);
        sleep(1);
    }
    
}

int main()
{
    signal(SIGINT,func); //键盘中断Ctrl+c
    signal(SIGTERM,func); //采用kill + 进程id通知程序
    for(;;)
    {
        exectask(); //执行任务
        sleep(5);
    }
}
</code></pre>
</details>  

a)信号被其他信号打断  
<details><summary>展开/收起</summary>
<pre><code>
执行了一次任务！
执行了一次任务！
收到了信号15，第0
收到了信号15，第1
收到了信号15，第2
收到了信号2，第0
收到了信号2，第1
收到了信号2，第2
收到了信号2，第3
收到了信号2，第4
收到了信号2，第5
收到了信号15，第3
收到了信号15，第4
收到了信号15，第5
执行了一次任务！
</code></pre>
</details>  

b) 同一个信号会排队阻塞  
<details><summary>展开/收起</summary>
<pre><code>
执行了一次任务！
执行了一次任务！
执行了一次任务！
执行了一次任务！
执行了一次任务！
^C收到了信号2，第0
收到了信号2，第1
收到了信号2，第2
收到了信号2，第3
收到了信号2，第4
收到了信号2，第5
执行了一次任务！
^C收到了信号2，第0
收到了信号2，第1
^C收到了信号2，第2
收到了信号2，第3
收到了信号2，第4
^C收到了信号2，第5
收到了信号2，第0
收到了信号2，第1
收到了信号2，第2
收到了信号2，第3
收到了信号2，第4

</code></pre>
</details>  



```
signal(SIGINT,SIG_IGN);
signal(SIGTERM,SIG_IGN);
```

* 设置中断的处理函数，收到信号后，由该函数来处理。
a) 
```
void func(int sig)
{
    printf("收到了信号%d\n",sig);
}
signal(SIGINT,func);
signal(SIGTERM,func);

```
* 进程对传递的信号采用系统默认的处理操作，大部分的默认操作是终止进程。  
3. 在实际开发中，信号用于服务程序的退出。



## 信号集
1. 使用信号集来记录当前进程正在响应的信号与阻塞的信号，信号集使用sigset_t的结构类型来表示，
```
typedef struct{
    unsigned long sig[2];
}sigset_t;
```
## 信号相关函数
## sigprocmask等信号函数的范例演示
